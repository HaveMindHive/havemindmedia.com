<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../../css/unified-theme.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cohort Engine | Reductive Comparison | [1=-1]</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #020208;
            color: #e8e4d9;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(201, 162, 39, 0.3);
            padding-bottom: 20px;
        }

        .header h1 {
            color: #c9a227;
            font-size: 1.4rem;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }

        .header .subtitle {
            color: #6e7a94;
            font-size: 0.75rem;
            letter-spacing: 2px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .cohort-box {
            background: rgba(5, 5, 16, 0.8);
            border: 1px solid rgba(106, 180, 245, 0.2);
            border-radius: 8px;
            padding: 15px;
        }

        .cohort-box.control { border-color: rgba(150, 150, 150, 0.3); }
        .cohort-box.bio { border-color: rgba(106, 180, 245, 0.4); }
        .cohort-box.q-sig { border-color: rgba(201, 162, 39, 0.5); }

        .cohort-box h3 {
            font-size: 0.7rem;
            letter-spacing: 2px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .cohort-box.control h3 { color: #888; }
        .cohort-box.bio h3 { color: #6ab4f5; }
        .cohort-box.q-sig h3 { color: #c9a227; }

        .stream-display {
            font-size: 0.8rem;
            line-height: 1.6;
            min-height: 80px;
            word-break: break-all;
            color: #9ba4b8;
        }

        .cohort-box.q-sig .stream-display { color: #c9a227; }

        .vector-display {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            text-align: center;
        }

        .axis-val {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .axis-val.x { color: #6ab4f5; }
        .axis-val.y { color: #7dd87d; }
        .axis-val.z { color: #c77daa; }

        .axis-label {
            font-size: 0.6rem;
            color: #6e7a94;
            letter-spacing: 1px;
        }

        .comparison-area {
            background: rgba(5, 5, 16, 0.9);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .comparison-area h3 {
            color: #c9a227;
            font-size: 0.8rem;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .semantic-search {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        .words-found {
            min-height: 100px;
        }

        .word-item {
            display: inline-block;
            padding: 4px 10px;
            margin: 3px;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 4px;
            font-size: 0.75rem;
            color: #c9a227;
        }

        .word-item.shadow {
            background: rgba(199, 125, 170, 0.15);
            border-color: rgba(199, 125, 170, 0.3);
            color: #c77daa;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.75rem;
        }

        .stat-row .label { color: #6e7a94; }
        .stat-row .value { color: #e8e4d9; }

        .message-area {
            background: rgba(201, 162, 39, 0.05);
            border: 2px solid rgba(201, 162, 39, 0.4);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            text-align: center;
            min-height: 120px;
        }

        .message-area h3 {
            color: #c9a227;
            font-size: 0.8rem;
            letter-spacing: 3px;
            margin-bottom: 15px;
        }

        .message-content {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #e8e4d9;
            font-style: italic;
        }

        .message-content.waiting {
            color: #6e7a94;
            font-style: normal;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            background: rgba(5, 5, 16, 0.9);
            border: 1px solid rgba(106, 180, 245, 0.4);
            color: #6ab4f5;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: #c9a227;
            color: #c9a227;
        }

        .btn.active {
            background: rgba(201, 162, 39, 0.2);
            border-color: #c9a227;
            color: #c9a227;
        }

        .btn.primary {
            background: rgba(201, 162, 39, 0.15);
            border-color: #c9a227;
            color: #c9a227;
        }

        .history-panel {
            background: rgba(5, 5, 16, 0.8);
            border: 1px solid rgba(106, 180, 245, 0.2);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .history-panel h3 {
            color: #6ab4f5;
            font-size: 0.7rem;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .history-item {
            font-size: 0.7rem;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            color: #9ba4b8;
        }

        .history-item .cohort-num { color: #6ab4f5; }
        .history-item .q-val { color: #c9a227; }
        .history-item .words { color: #7dd87d; }

        .epoch-sig {
            text-align: center;
            margin-top: 30px;
            color: #c9a227;
            font-size: 0.9rem;
        }

        .input-area {
            margin-bottom: 20px;
        }

        .input-area textarea {
            width: 100%;
            height: 60px;
            background: rgba(5, 5, 16, 0.9);
            border: 1px solid rgba(106, 180, 245, 0.3);
            border-radius: 8px;
            padding: 12px;
            color: #e8e4d9;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            resize: none;
        }

        .input-area textarea:focus {
            outline: none;
            border-color: #c9a227;
        }

        .input-hint {
            font-size: 0.65rem;
            color: #6e7a94;
            margin-top: 5px;
            text-align: center;
        }

        .home-link {
            position: fixed;
            top: 15px;
            left: 20px;
            z-index: 10001;
        }
        .home-link a {
            color: #c9a227;
            text-decoration: none;
            padding: 8px 15px;
            border: 1px solid #c9a227;
            border-radius: 3px;
            background: rgba(10, 10, 15, 0.95);
            font-family: sans-serif;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        .home-link a:hover {
            background: #c9a227;
            color: #000;
        }
    </style>
    <script src="../../js/components/site-header.js" defer></script>
    <script src="../../js/components/site-footer.js" defer></script>
</head>
<body>
    <site-header></site-header>
    <div class="home-link">
        <a href="/">← Home</a>
    </div>

    <div class="header">
        <h1>COHORT COMPARISON ENGINE</h1>
        <div class="subtitle">REDUCTIVE METHOD | Q-SIGNATURE = BIO - CONTROL | [1=-1]</div>
    </div>

    <div class="input-area">
        <textarea id="userInput" placeholder="Type to influence the bio-stream... your words become entropy seeds"></textarea>
        <div class="input-hint">EVERY KEYSTROKE = BIO-INFLUENCE | SHADOW CHANNEL ACTIVE</div>
    </div>

    <div class="controls">
        <button class="btn active" id="btnRun" onclick="toggleRunning()">RUNNING</button>
        <button class="btn primary" onclick="generateCohort()">GENERATE COHORT</button>
        <button class="btn" onclick="resetAll()">RESET</button>
    </div>

    <div class="main-grid">
        <div class="cohort-box control">
            <h3>COHORT A (CONTROL)</h3>
            <div class="stream-display" id="controlStream">---</div>
            <div class="vector-display">
                <div><div class="axis-val x" id="ctrlX">0</div><div class="axis-label">X</div></div>
                <div><div class="axis-val y" id="ctrlY">0</div><div class="axis-label">Y</div></div>
                <div><div class="axis-val z" id="ctrlZ">0</div><div class="axis-label">Z</div></div>
            </div>
        </div>

        <div class="cohort-box bio">
            <h3>COHORT B (BIO-INFLUENCED)</h3>
            <div class="stream-display" id="bioStream">---</div>
            <div class="vector-display">
                <div><div class="axis-val x" id="bioX">0</div><div class="axis-label">X</div></div>
                <div><div class="axis-val y" id="bioY">0</div><div class="axis-label">Y</div></div>
                <div><div class="axis-val z" id="bioZ">0</div><div class="axis-label">Z</div></div>
            </div>
        </div>

        <div class="cohort-box q-sig">
            <h3>Q-SIGNATURE (B - A)</h3>
            <div class="stream-display" id="qStream">---</div>
            <div class="vector-display">
                <div><div class="axis-val x" id="qX">0</div><div class="axis-label">X</div></div>
                <div><div class="axis-val y" id="qY">0</div><div class="axis-label">Y</div></div>
                <div><div class="axis-val z" id="qZ">0</div><div class="axis-label">Z</div></div>
            </div>
        </div>
    </div>

    <div class="message-area">
        <h3>MESSAGE FROM THE ETHER</h3>
        <div class="message-content waiting" id="messageContent">
            Waiting for signal... generating cohorts...
        </div>
    </div>

    <div class="comparison-area">
        <h3>SEMANTIC EXTRACTION</h3>
        <div class="semantic-search">
            <div class="words-found" id="wordsFound">
                <span style="color: #6e7a94; font-size: 0.75rem;">Words will appear as they emerge from the Q-signature...</span>
            </div>
            <div class="stats-panel">
                <div class="stat-row">
                    <span class="label">Cohorts Generated</span>
                    <span class="value" id="cohortCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="label">Total Samples</span>
                    <span class="value" id="sampleCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="label">Words Found</span>
                    <span class="value" id="wordCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="label">Semantic Density</span>
                    <span class="value" id="semanticDensity">0%</span>
                </div>
                <div class="stat-row">
                    <span class="label">|Q| Magnitude</span>
                    <span class="value" id="qMagnitude">0.00</span>
                </div>
            </div>
        </div>
    </div>

    <div class="history-panel">
        <h3>COHORT HISTORY</h3>
        <div id="historyList"></div>
    </div>

    <div class="epoch-sig">[1 = -1]</div>

    <script>
        // ═══════════════════════════════════════════════════════════════════
        // COHORT COMPARISON ENGINE
        // The Randomness Engine + Q Mathematics Integration
        //
        // Method: Generate control (A) and bio-influenced (B) cohorts
        // Q-signature = B - A reveals the bio-effect
        // Semantic extraction finds meaning in the difference
        //
        // "just keep comparing one cohort to the next"
        // ═══════════════════════════════════════════════════════════════════

        // Triaxial symbols
        const SYMBOLS = ['>', '<', '^', 'v', '.', ','];
        const SYMBOL_MAP = {
            '>': { axis: 'x', dir: 1 },   // Future, S+
            '<': { axis: 'x', dir: -1 },  // Past, S-
            '^': { axis: 'y', dir: 1 },   // Rising
            'v': { axis: 'y', dir: -1 },  // Ground
            '.': { axis: 'z', dir: 1 },   // Present
            ',': { axis: 'z', dir: -1 }   // Process
        };

        // Word lists for semantic detection
        const SACRED_WORDS = [
            'LOVE', 'AHAVA', 'ANNA', 'SOUL', 'SHIVA', 'VIA', 'HEAL', 'MIND',
            'LIGHT', 'DARK', 'VOID', 'ONE', 'ALL', 'NOW', 'HERE', 'THERE',
            'TRUTH', 'REAL', 'SELF', 'GOD', 'LIFE', 'DEATH', 'BIRTH',
            'MOTHER', 'FATHER', 'CHILD', 'WHOLE', 'PART', 'WAVE', 'FORM',
            'RAY', 'SUN', 'MOON', 'STAR', 'EARTH', 'FIRE', 'WATER', 'AIR',
            'YES', 'NO', 'AND', 'OR', 'NOT', 'IS', 'BE', 'AM', 'WE', 'I',
            'Q', 'S', 'M', 'JASON', 'EPOCH', 'OMEGA', 'ALPHA'
        ];

        // State
        let isRunning = true;
        let bioInfluence = 0;
        let lastInputTime = Date.now();
        let cohortCount = 0;
        let totalSamples = 0;
        let foundWords = new Set();
        let messageBuffer = '';
        let cohortHistory = [];

        // Current cohort data
        let currentControl = { stream: '', vector: { x: 0, y: 0, z: 0 } };
        let currentBio = { stream: '', vector: { x: 0, y: 0, z: 0 } };
        let accumulatedQ = { x: 0, y: 0, z: 0 };

        // ═══════════════════════════════════════════════════════════════════
        // SYMBOL GENERATION
        // ═══════════════════════════════════════════════════════════════════

        function generateControlSymbol() {
            return SYMBOLS[Math.floor(Math.random() * 6)];
        }

        function generateBioSymbol() {
            const timeSince = (Date.now() - lastInputTime) / 1000;
            const bioFactor = bioInfluence * Math.exp(-timeSince / 8);

            // Bio-influence shifts probability toward S+ (future, rising, present)
            const weights = [
                0.167 + bioFactor * 0.12,  // >
                0.167 - bioFactor * 0.08,  // <
                0.167 + bioFactor * 0.10,  // ^
                0.167 - bioFactor * 0.10,  // v
                0.167 + bioFactor * 0.06,  // .
                0.167 - bioFactor * 0.10   // ,
            ];

            const total = weights.reduce((a, b) => a + b, 0);
            const rand = Math.random() * total;
            let cumulative = 0;

            for (let i = 0; i < 6; i++) {
                cumulative += weights[i];
                if (rand < cumulative) return SYMBOLS[i];
            }
            return SYMBOLS[0];
        }

        function processSymbol(symbol, vector) {
            const mapping = SYMBOL_MAP[symbol];
            vector[mapping.axis] += mapping.dir;
        }

        // ═══════════════════════════════════════════════════════════════════
        // COHORT GENERATION
        // ═══════════════════════════════════════════════════════════════════

        function generateSample() {
            if (!isRunning) return;

            // Generate both streams
            const ctrlSym = generateControlSymbol();
            const bioSym = generateBioSymbol();

            // Update streams
            currentControl.stream = (currentControl.stream + ctrlSym).slice(-60);
            currentBio.stream = (currentBio.stream + bioSym).slice(-60);

            // Update vectors
            processSymbol(ctrlSym, currentControl.vector);
            processSymbol(bioSym, currentBio.vector);

            totalSamples++;

            // Update display
            updateDisplay();

            // Decay bio-influence
            bioInfluence *= 0.9995;
        }

        function generateCohort() {
            cohortCount++;

            // Calculate Q-signature for this cohort
            const qSig = {
                x: currentBio.vector.x - currentControl.vector.x,
                y: currentBio.vector.y - currentControl.vector.y,
                z: currentBio.vector.z - currentControl.vector.z
            };

            // Accumulate Q
            accumulatedQ.x += qSig.x;
            accumulatedQ.y += qSig.y;
            accumulatedQ.z += qSig.z;

            // Search for words in Q-stream
            const qStream = currentBio.stream; // Use bio stream for semantic search
            searchForWords(qStream);

            // Save to history
            const historyEntry = {
                num: cohortCount,
                q: { ...qSig },
                words: [...foundWords].slice(-5),
                mag: magnitude(qSig)
            };
            cohortHistory.unshift(historyEntry);
            if (cohortHistory.length > 20) cohortHistory.pop();

            updateHistory();

            // Check for message emergence
            checkForMessage();

            // Reset for next cohort
            currentControl = { stream: '', vector: { x: 0, y: 0, z: 0 } };
            currentBio = { stream: '', vector: { x: 0, y: 0, z: 0 } };
        }

        // ═══════════════════════════════════════════════════════════════════
        // SEMANTIC EXTRACTION
        // ═══════════════════════════════════════════════════════════════════

        function searchForWords(stream) {
            // Convert triaxial symbols to letters
            // This is a simple mapping - could be more sophisticated
            const letterStream = symbolsToLetters(stream);

            // Search for sacred words
            for (const word of SACRED_WORDS) {
                if (letterStream.includes(word) || letterStream.includes(word.toLowerCase())) {
                    if (!foundWords.has(word)) {
                        foundWords.add(word);
                        addWordToDisplay(word, false);
                    }
                }
            }

            // Also check the shadow (reversed stream)
            const shadowStream = symbolsToLetters(stream.split('').reverse().join(''));
            for (const word of SACRED_WORDS) {
                if (shadowStream.includes(word)) {
                    const shadowWord = word + "'"; // Mark as shadow
                    if (!foundWords.has(shadowWord)) {
                        foundWords.add(shadowWord);
                        addWordToDisplay(word, true);
                    }
                }
            }
        }

        function symbolsToLetters(stream) {
            // Map symbols to letter-like representations
            // This creates pseudo-text from the triaxial stream
            let result = '';
            for (let i = 0; i < stream.length - 2; i += 3) {
                const triplet = stream.substring(i, i + 3);
                const code = tripletToCode(triplet);
                if (code >= 65 && code <= 90) {
                    result += String.fromCharCode(code);
                } else if (code >= 97 && code <= 122) {
                    result += String.fromCharCode(code);
                }
            }
            return result;
        }

        function tripletToCode(triplet) {
            // Convert 3 symbols to a character code
            let value = 0;
            for (let i = 0; i < triplet.length; i++) {
                const idx = SYMBOLS.indexOf(triplet[i]);
                if (idx >= 0) value += idx * Math.pow(6, i);
            }
            return 65 + (value % 26); // A-Z
        }

        function addWordToDisplay(word, isShadow) {
            const container = document.getElementById('wordsFound');
            if (container.querySelector('span')) {
                container.innerHTML = '';
            }

            const wordEl = document.createElement('span');
            wordEl.className = 'word-item' + (isShadow ? ' shadow' : '');
            wordEl.textContent = word + (isShadow ? "'" : '');
            container.appendChild(wordEl);

            document.getElementById('wordCount').textContent = foundWords.size;
            updateSemanticDensity();
        }

        function updateSemanticDensity() {
            const density = Math.min(100, (foundWords.size / cohortCount * 100) || 0);
            document.getElementById('semanticDensity').textContent = density.toFixed(1) + '%';
        }

        // ═══════════════════════════════════════════════════════════════════
        // MESSAGE EMERGENCE
        // ═══════════════════════════════════════════════════════════════════

        function checkForMessage() {
            const mag = magnitude(accumulatedQ);
            const words = [...foundWords];

            // Message emerges when:
            // 1. Sufficient magnitude (signal strength)
            // 2. Sufficient words (semantic content)
            // 3. Coherent direction (consistent Q-signature)

            if (mag > 50 && words.length >= 3) {
                const direction = getDirection(accumulatedQ);
                const message = constructMessage(words, direction);
                displayMessage(message);
            } else if (cohortCount > 0 && cohortCount % 10 === 0) {
                // Periodic status
                const status = `Gathering signal... |Q|=${mag.toFixed(1)}, words=${words.length}`;
                document.getElementById('messageContent').textContent = status;
                document.getElementById('messageContent').className = 'message-content waiting';
            }
        }

        function getDirection(q) {
            const parts = [];
            if (q.x > 5) parts.push('future-facing');
            else if (q.x < -5) parts.push('past-anchored');
            if (q.y > 5) parts.push('rising');
            else if (q.y < -5) parts.push('grounding');
            if (q.z > 5) parts.push('present');
            else if (q.z < -5) parts.push('processing');
            return parts.join(', ') || 'balanced';
        }

        function constructMessage(words, direction) {
            // Combine found words into a message
            // Priority: LOVE, SOUL, TRUTH, then others
            const priority = ['LOVE', 'AHAVA', 'SOUL', 'TRUTH', 'LIGHT', 'HEAL', 'ONE', 'WE'];
            const sorted = words.sort((a, b) => {
                const aIdx = priority.indexOf(a.replace("'", ''));
                const bIdx = priority.indexOf(b.replace("'", ''));
                if (aIdx === -1 && bIdx === -1) return 0;
                if (aIdx === -1) return 1;
                if (bIdx === -1) return -1;
                return aIdx - bIdx;
            });

            const mainWords = sorted.slice(0, 4).join(' ');
            return `${mainWords} (${direction})`;
        }

        function displayMessage(message) {
            const el = document.getElementById('messageContent');
            el.textContent = message;
            el.className = 'message-content';

            // Add to message buffer
            messageBuffer = message;
        }

        // ═══════════════════════════════════════════════════════════════════
        // DISPLAY UPDATES
        // ═══════════════════════════════════════════════════════════════════

        function updateDisplay() {
            // Control
            document.getElementById('controlStream').textContent = currentControl.stream || '---';
            document.getElementById('ctrlX').textContent = currentControl.vector.x;
            document.getElementById('ctrlY').textContent = currentControl.vector.y;
            document.getElementById('ctrlZ').textContent = currentControl.vector.z;

            // Bio
            document.getElementById('bioStream').textContent = currentBio.stream || '---';
            document.getElementById('bioX').textContent = currentBio.vector.x;
            document.getElementById('bioY').textContent = currentBio.vector.y;
            document.getElementById('bioZ').textContent = currentBio.vector.z;

            // Q-signature (accumulated)
            document.getElementById('qStream').textContent =
                `X:${accumulatedQ.x} Y:${accumulatedQ.y} Z:${accumulatedQ.z}`;
            document.getElementById('qX').textContent = accumulatedQ.x;
            document.getElementById('qY').textContent = accumulatedQ.y;
            document.getElementById('qZ').textContent = accumulatedQ.z;

            // Stats
            document.getElementById('cohortCount').textContent = cohortCount;
            document.getElementById('sampleCount').textContent = totalSamples;
            document.getElementById('qMagnitude').textContent = magnitude(accumulatedQ).toFixed(2);
        }

        function updateHistory() {
            const container = document.getElementById('historyList');
            container.innerHTML = cohortHistory.map(h => `
                <div class="history-item">
                    <span class="cohort-num">#${h.num}</span>
                    <span class="q-val">Q:(${h.q.x},${h.q.y},${h.q.z})</span>
                    <span class="words">${h.words.join(',') || '-'}</span>
                </div>
            `).join('');
        }

        function magnitude(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
        }

        // ═══════════════════════════════════════════════════════════════════
        // CONTROLS
        // ═══════════════════════════════════════════════════════════════════

        function toggleRunning() {
            isRunning = !isRunning;
            const btn = document.getElementById('btnRun');
            btn.textContent = isRunning ? 'RUNNING' : 'PAUSED';
            btn.classList.toggle('active', isRunning);
        }

        function resetAll() {
            currentControl = { stream: '', vector: { x: 0, y: 0, z: 0 } };
            currentBio = { stream: '', vector: { x: 0, y: 0, z: 0 } };
            accumulatedQ = { x: 0, y: 0, z: 0 };
            cohortCount = 0;
            totalSamples = 0;
            foundWords = new Set();
            cohortHistory = [];
            bioInfluence = 0;
            messageBuffer = '';

            document.getElementById('wordsFound').innerHTML =
                '<span style="color: #6e7a94; font-size: 0.75rem;">Words will appear as they emerge...</span>';
            document.getElementById('messageContent').textContent = 'Waiting for signal...';
            document.getElementById('messageContent').className = 'message-content waiting';

            updateDisplay();
            updateHistory();
        }

        // ═══════════════════════════════════════════════════════════════════
        // INPUT HANDLING
        // ═══════════════════════════════════════════════════════════════════

        function handleInput(e) {
            lastInputTime = Date.now();

            const char = e.data || e.key || '';

            // Different characters add different bio-influence
            if (char.match(/[a-zA-Z]/)) {
                bioInfluence += 0.15;
            } else if (char.match(/[>^.]/)) {
                bioInfluence += 0.4; // S+ symbols
            } else if (char.match(/[<v,]/)) {
                bioInfluence += 0.25; // S- symbols
            } else {
                bioInfluence += 0.05;
            }

            bioInfluence = Math.min(bioInfluence, 8);
        }

        // ═══════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════

        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('userInput');
            input.addEventListener('input', handleInput);
            input.addEventListener('keydown', handleInput);

            // Sample generation loop
            setInterval(generateSample, 50);

            // Auto-generate cohorts every 3 seconds
            setInterval(() => {
                if (isRunning && currentBio.stream.length >= 30) {
                    generateCohort();
                }
            }, 3000);

            console.log('Cohort Engine initialized');
            console.log('Method: Q-signature = Bio - Control');
            console.log('Framework: [1=-1]');
        });
    </script>
    <site-footer></site-footer>
</body>
</html>
