<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol Sender | Have Mind Media</title>
    <style>
        :root {
            --gold: #FFD700;
            --bg-deep: #0a0a1a;
            --bg-purple: #1a0a2e;
            --text-light: #e0e0e0;
            --success: #4CAF50;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--bg-deep) 0%, var(--bg-purple) 100%);
            min-height: 100vh;
            color: var(--text-light);
        }

        .home-nav {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
        }
        .home-nav a {
            display: inline-block;
            color: #c9a227;
            text-decoration: none;
            padding: 8px 16px;
            border: 1px solid #c9a227;
            border-radius: 4px;
            background: rgba(10, 10, 26, 0.95);
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .home-nav a:hover {
            background: #c9a227;
            color: #0a0a1a;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, var(--gold), #fff, var(--gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            opacity: 0.8;
            margin-top: 5px;
        }

        .epoch-mark {
            color: var(--gold);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .instruction {
            text-align: center;
            margin: 20px 0;
            line-height: 1.7;
            opacity: 0.9;
        }

        /* Wave Display */
        .wave-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
        }

        .wave-canvas-wrapper {
            position: relative;
            margin-bottom: 20px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.2);
        }

        #waveCanvas {
            background: linear-gradient(180deg, #0a0a1a, #1a0a2e);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
        }

        .frequency-label {
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
            margin-top: 10px;
        }

        /* Audio Controls */
        .audio-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }

        .audio-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
        }

        .audio-toggle input {
            width: 18px;
            height: 18px;
            accent-color: var(--gold);
        }

        .volume-slider {
            width: 100px;
            accent-color: var(--gold);
        }

        /* Word Choices */
        .word-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            max-width: 450px;
            margin: 30px auto;
        }

        .word-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px 15px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .word-btn:hover {
            border-color: var(--gold);
            transform: scale(1.03);
        }

        .word-btn .word {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .word-btn .category {
            font-size: 0.75rem;
            opacity: 0.6;
            text-transform: uppercase;
        }

        .word-btn.correct {
            border-color: var(--success);
            background: rgba(76, 175, 80, 0.2);
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.4);
        }

        .word-btn.incorrect {
            border-color: #f44336;
            opacity: 0.5;
        }

        .word-btn.reveal {
            border-color: var(--gold);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
        }

        /* Transmission Controls */
        .transmission-controls {
            text-align: center;
            margin: 20px 0;
        }

        .transmission-status {
            font-size: 1.1rem;
            color: var(--gold);
            margin-bottom: 15px;
        }

        .transmission-status.active {
            animation: statusPulse 1.5s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stats-bar {
            display: flex;
            justify-content: space-around;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .stat { text-align: center; }
        .stat-label { font-size: 0.75rem; opacity: 0.7; text-transform: uppercase; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: var(--gold); }

        /* Session History */
        .session-history {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .history-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
        }

        .history-dot.hit { background: var(--success); }
        .history-dot.miss { background: #f44336; }

        /* Result */
        .result {
            font-size: 1.5rem;
            font-weight: bold;
            min-height: 40px;
            margin: 20px 0;
            text-align: center;
        }

        .result.hit { color: var(--success); }
        .result.miss { color: #f44336; }

        /* Target Reveal */
        .target-reveal {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 15px;
        }

        .target-word {
            font-size: 2rem;
            color: var(--gold);
            margin: 10px 0;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, var(--gold), #ffa500);
            border: none;
            padding: 12px 25px;
            font-size: 1rem;
            font-weight: bold;
            color: var(--bg-deep);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        /* Protocol Box */
        .protocol {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin: 30px 0;
            text-align: left;
        }

        .protocol h3 {
            color: var(--gold);
            margin-bottom: 15px;
        }

        .protocol p, .protocol li {
            line-height: 1.8;
            opacity: 0.9;
        }

        .protocol ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        footer {
            text-align: center;
            padding: 30px;
            opacity: 0.6;
            font-size: 0.9rem;
        }

        footer a { color: var(--gold); text-decoration: none; }
    </style>
</head>
<body>
    <div class="home-nav"><a href="/">← Home</a></div>
    <div class="container">
        <header>
            <h1>Symbol Sender</h1>
            <p class="subtitle">Geometric Harmonic Transmission · Word Frequency Echo</p>
            <p class="epoch-mark">[1 = -1]</p>
        </header>

        <p class="instruction">
            The device transmits a word as colored waves and harmonic tones.<br>
            Each word has a unique frequency signature—its visual and auditory "echo."<br>
            Receive the pattern. Feel which word resonates.
        </p>

        <div class="wave-container">
            <div class="wave-canvas-wrapper">
                <canvas id="waveCanvas" width="600" height="250"></canvas>
            </div>
            <div class="frequency-label" id="frequencyLabel">Awaiting transmission...</div>
        </div>

        <div class="audio-controls">
            <label class="audio-toggle">
                <input type="checkbox" id="audioToggle" checked>
                Sound enabled
            </label>
            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="30">
        </div>

        <div class="transmission-controls">
            <div class="transmission-status" id="transmissionStatus">Ready to transmit</div>
            <button onclick="startTransmission()">Begin Transmission</button>
        </div>

        <p class="instruction" style="margin-top: 30px;">
            Which word is being transmitted? (3 choices = 33.3% chance)
        </p>

        <div class="word-grid" id="wordGrid">
            <!-- Populated by JS -->
        </div>

        <div class="result" id="result"></div>

        <div class="target-reveal" id="targetReveal" style="display: none;">
            <p style="opacity: 0.7;">The transmitted word was:</p>
            <div class="target-word" id="targetWord"></div>
        </div>

        <div class="stats-bar">
            <div class="stat">
                <div class="stat-label">Transmissions</div>
                <div class="stat-value" id="sessions">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Received</div>
                <div class="stat-value" id="hits">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Reception Rate</div>
                <div class="stat-value" id="hitRate">0%</div>
            </div>
            <div class="stat">
                <div class="stat-label">vs 33.3%</div>
                <div class="stat-value" id="vsChance">--</div>
            </div>
        </div>

        <div class="session-history" id="sessionHistory"></div>

        <div class="controls">
            <button onclick="newSession()">New Transmission</button>
            <button class="secondary" onclick="resetStats()">Reset Stats</button>
        </div>

        <div class="protocol">
            <h3>Word Frequency Harmonics</h3>
            <p>Every word carries a unique vibrational signature derived from:</p>
            <ul>
                <li><strong>Letter values:</strong> A=1, B=2... Z=26 (Pythagorean base)</li>
                <li><strong>Vowel resonance:</strong> Vowels create warm colors (reds, oranges) and lower tones</li>
                <li><strong>Consonant structure:</strong> Consonants create cool colors (blues, purples) and higher tones</li>
                <li><strong>Q-reduction:</strong> Sum reduced to single digit (1-9) determines wave speed</li>
                <li><strong>Harmonic layers:</strong> 3 wave frequencies combine into the visual pattern</li>
            </ul>
            <p style="margin-top: 15px;">
                The waves and tones you experience are the word's "echo"—its frequency signature.
                Your task is to feel which word resonates, not to analyze.
            </p>
            <p style="margin-top: 10px; color: var(--gold);">
                <strong>Triaxial Design:</strong> Always 3 word choices. 33.3% chance rate.
            </p>
        </div>
    </div>

    <footer>
        <p>Have Mind Media | Developer: Alessandra Ray</p>
        <a href="index.html">Back to Games</a>
    </footer>

    <script>
        // ══════════════════════════════════════════════════════════════
        // WORD POOLS (Triaxial: 3 words per category)
        // ══════════════════════════════════════════════════════════════

        const WORD_POOLS = [
            { category: 'Animal', words: ['BULL', 'EAGLE', 'WOLF'] },
            { category: 'Animal', words: ['LION', 'SERPENT', 'BEAR'] },
            { category: 'Animal', words: ['HAWK', 'SPIDER', 'HORSE'] },
            { category: 'Element', words: ['FIRE', 'WATER', 'STONE'] },
            { category: 'Element', words: ['WIND', 'EARTH', 'METAL'] },
            { category: 'Element', words: ['LIGHT', 'SHADOW', 'VOID'] },
            { category: 'Object', words: ['SWORD', 'MIRROR', 'CROWN'] },
            { category: 'Object', words: ['KEY', 'WHEEL', 'TOWER'] },
            { category: 'Object', words: ['BRIDGE', 'FLAME', 'GATE'] },
            { category: 'Concept', words: ['TRUTH', 'POWER', 'LOVE'] },
            { category: 'Concept', words: ['CHAOS', 'ORDER', 'CHANGE'] },
            { category: 'Concept', words: ['DEATH', 'BIRTH', 'DREAM'] }
        ];

        // ══════════════════════════════════════════════════════════════
        // STATE
        // ══════════════════════════════════════════════════════════════

        let currentPool = null;
        let targetWord = null;
        let isRevealed = false;
        let isTransmitting = false;
        let animationFrame = null;
        let audioContext = null;
        let oscillators = [];
        let gainNodes = [];

        const stats = {
            sessions: 0,
            hits: 0,
            history: []
        };

        // ══════════════════════════════════════════════════════════════
        // WORD FREQUENCY CALCULATION
        // ══════════════════════════════════════════════════════════════

        function getLetterValue(letter) {
            return letter.toUpperCase().charCodeAt(0) - 64;
        }

        function isVowel(letter) {
            return 'AEIOU'.includes(letter.toUpperCase());
        }

        function calculateWordFrequency(word) {
            let sum = 0;
            let vowelSum = 0;
            let consonantSum = 0;
            let vowelCount = 0;
            let consonantCount = 0;
            const letterValues = [];

            for (const letter of word.toUpperCase()) {
                if (letter >= 'A' && letter <= 'Z') {
                    const val = getLetterValue(letter);
                    letterValues.push(val);
                    sum += val;
                    if (isVowel(letter)) {
                        vowelSum += val;
                        vowelCount++;
                    } else {
                        consonantSum += val;
                        consonantCount++;
                    }
                }
            }

            // Q-reduction to single digit
            let qReduced = sum;
            while (qReduced > 9) {
                qReduced = String(qReduced).split('').reduce((a, b) => a + parseInt(b), 0);
            }

            return {
                total: sum,
                qReduced: qReduced,
                vowelRatio: vowelCount / word.length,
                consonantRatio: consonantCount / word.length,
                vowelEnergy: vowelSum,
                consonantEnergy: consonantSum,
                amplitude: (vowelSum / (vowelCount || 1)) / 26,
                wordLength: word.length,
                letterValues: letterValues,
                // Color derived from frequency
                hue: (sum * 7) % 360,
                saturation: 50 + (vowelRatio * 50),
                // Audio frequencies
                baseFreq: 200 + (qReduced * 30), // 200-470 Hz range
                harmonic2: 250 + (vowelSum % 150),
                harmonic3: 300 + (consonantSum % 200)
            };
        }

        // ══════════════════════════════════════════════════════════════
        // WAVE VISUALIZATION
        // ══════════════════════════════════════════════════════════════

        function drawColoredWaves(canvas, word, time) {
            const ctx = canvas.getContext('2d');
            const freq = calculateWordFrequency(word);
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;

            // Clear with fade effect
            ctx.fillStyle = 'rgba(10, 10, 26, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Wave parameters based on word frequency
            const waveSpeed = 0.001 + (freq.qReduced * 0.0003);
            const waves = [
                {
                    freq: 0.02 + freq.vowelRatio * 0.01,
                    amp: 30 + freq.vowelEnergy * 0.5,
                    hue: freq.hue,
                    phase: time * waveSpeed,
                    alpha: 0.8
                },
                {
                    freq: 0.015 + freq.consonantRatio * 0.015,
                    amp: 25 + freq.consonantEnergy * 0.3,
                    hue: (freq.hue + 120) % 360,
                    phase: time * waveSpeed * 1.3 + Math.PI / 3,
                    alpha: 0.6
                },
                {
                    freq: 0.025 + (freq.qReduced * 0.002),
                    amp: 20 + freq.total * 0.15,
                    hue: (freq.hue + 240) % 360,
                    phase: time * waveSpeed * 0.7 + Math.PI / 6,
                    alpha: 0.5
                }
            ];

            // Draw each wave layer
            waves.forEach((wave, index) => {
                ctx.beginPath();

                // Create gradient for this wave
                const gradient = ctx.createLinearGradient(0, centerY - wave.amp, 0, centerY + wave.amp);
                gradient.addColorStop(0, `hsla(${wave.hue}, 80%, 60%, ${wave.alpha})`);
                gradient.addColorStop(0.5, `hsla(${wave.hue}, 90%, 50%, ${wave.alpha * 0.8})`);
                gradient.addColorStop(1, `hsla(${(wave.hue + 30) % 360}, 80%, 40%, ${wave.alpha * 0.6})`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3 - index * 0.5;

                for (let x = 0; x < width; x++) {
                    // Combine multiple sine waves for complexity
                    let y = centerY;
                    y += Math.sin(x * wave.freq + wave.phase) * wave.amp;
                    y += Math.sin(x * wave.freq * 2 + wave.phase * 1.5) * (wave.amp * 0.3);
                    y += Math.sin(x * wave.freq * 0.5 + wave.phase * 0.7) * (wave.amp * 0.2);

                    // Add letter-based modulation
                    const letterIndex = Math.floor(x / (width / freq.wordLength));
                    if (letterIndex < freq.letterValues.length) {
                        y += Math.sin(x * 0.05 + time * 0.002) * (freq.letterValues[letterIndex] * 0.5);
                    }

                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();

                // Add glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = `hsla(${wave.hue}, 80%, 50%, 0.5)`;
                ctx.stroke();
                ctx.shadowBlur = 0;
            });

            // Draw center line pulse
            const pulseIntensity = (Math.sin(time * 0.003) + 1) * 0.5;
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255, 215, 0, ${0.1 + pulseIntensity * 0.2})`;
            ctx.lineWidth = 1;
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();

            // Draw frequency markers
            ctx.fillStyle = `hsla(${freq.hue}, 80%, 60%, 0.3)`;
            for (let i = 0; i < freq.wordLength; i++) {
                const x = (i + 0.5) * (width / freq.wordLength);
                const markerHeight = freq.letterValues[i] * 2;
                ctx.fillRect(x - 1, centerY - markerHeight / 2, 2, markerHeight);
            }
        }

        function animateWaves() {
            if (!isTransmitting) return;

            const canvas = document.getElementById('waveCanvas');
            const time = Date.now();
            drawColoredWaves(canvas, targetWord, time);
            animationFrame = requestAnimationFrame(animateWaves);
        }

        // ══════════════════════════════════════════════════════════════
        // AUDIO GENERATION
        // ══════════════════════════════════════════════════════════════

        function startAudio() {
            if (!document.getElementById('audioToggle').checked) return;

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const freq = calculateWordFrequency(targetWord);
            const volume = document.getElementById('volumeSlider').value / 100 * 0.15;

            // Create 3 harmonic oscillators
            const frequencies = [freq.baseFreq, freq.harmonic2, freq.harmonic3];
            const types = ['sine', 'triangle', 'sine'];

            frequencies.forEach((f, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = types[i];
                osc.frequency.setValueAtTime(f, audioContext.currentTime);

                // Modulate frequency slightly for organic feel
                osc.frequency.linearRampToValueAtTime(f * 1.02, audioContext.currentTime + 2);
                osc.frequency.linearRampToValueAtTime(f * 0.98, audioContext.currentTime + 4);
                osc.frequency.linearRampToValueAtTime(f, audioContext.currentTime + 6);

                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(volume / (i + 1), audioContext.currentTime + 0.5);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start();
                oscillators.push(osc);
                gainNodes.push(gain);
            });

            // Add subtle LFO modulation
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.setValueAtTime(freq.qReduced * 0.5, audioContext.currentTime);
            lfoGain.gain.setValueAtTime(5, audioContext.currentTime);
            lfo.connect(lfoGain);
            if (oscillators[0]) {
                lfoGain.connect(oscillators[0].frequency);
            }
            lfo.start();
            oscillators.push(lfo);
        }

        function stopAudio() {
            gainNodes.forEach(gain => {
                if (gain && audioContext) {
                    gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                }
            });

            setTimeout(() => {
                oscillators.forEach(osc => {
                    try { osc.stop(); } catch (e) {}
                });
                oscillators = [];
                gainNodes = [];
            }, 400);
        }

        // ══════════════════════════════════════════════════════════════
        // SESSION MANAGEMENT
        // ══════════════════════════════════════════════════════════════

        function newSession() {
            isRevealed = false;
            isTransmitting = false;

            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            stopAudio();

            // Select random pool and target
            currentPool = WORD_POOLS[Math.floor(Math.random() * WORD_POOLS.length)];
            const shuffled = [...currentPool.words].sort(() => Math.random() - 0.5);
            targetWord = shuffled[Math.floor(Math.random() * shuffled.length)];

            // Reset UI
            document.getElementById('result').textContent = '';
            document.getElementById('result').className = 'result';
            document.getElementById('targetReveal').style.display = 'none';
            document.getElementById('transmissionStatus').textContent = 'Ready to transmit';
            document.getElementById('transmissionStatus').classList.remove('active');
            document.getElementById('frequencyLabel').textContent = 'Awaiting transmission...';

            // Clear canvas
            const canvas = document.getElementById('waveCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Reset word button styles
            document.querySelectorAll('.word-btn').forEach(btn => {
                btn.classList.remove('correct', 'incorrect', 'reveal');
            });

            // Render word choices
            renderWordChoices();
        }

        function renderWordChoices() {
            const grid = document.getElementById('wordGrid');
            const shuffled = [...currentPool.words].sort(() => Math.random() - 0.5);

            grid.innerHTML = shuffled.map(word => `
                <div class="word-btn" data-word="${word}">
                    <div class="word">${word}</div>
                    <div class="category">${currentPool.category}</div>
                </div>
            `).join('');

            grid.querySelectorAll('.word-btn').forEach(btn => {
                btn.addEventListener('click', () => handleChoice(btn.dataset.word));
            });
        }

        function startTransmission() {
            if (isTransmitting || isRevealed) return;

            isTransmitting = true;
            document.getElementById('transmissionStatus').textContent = 'Transmitting frequency pattern...';
            document.getElementById('transmissionStatus').classList.add('active');

            const freq = calculateWordFrequency(targetWord);
            document.getElementById('frequencyLabel').textContent =
                `Q-${freq.qReduced} · ${freq.wordLength} letters · ${Math.round(freq.baseFreq)}Hz base`;

            animateWaves();
            startAudio();
        }

        function handleChoice(chosenWord) {
            if (!isTransmitting || isRevealed) return;

            isRevealed = true;
            isTransmitting = false;
            stats.sessions++;

            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            stopAudio();

            const isHit = chosenWord === targetWord;
            if (isHit) stats.hits++;
            stats.history.push(isHit);

            // Update transmission status
            document.getElementById('transmissionStatus').textContent = 'Transmission complete';
            document.getElementById('transmissionStatus').classList.remove('active');

            // Show result
            const resultEl = document.getElementById('result');
            if (isHit) {
                resultEl.textContent = 'RECEIVED! Frequency matched.';
                resultEl.className = 'result hit';
            } else {
                resultEl.textContent = 'Interference. Frequency mismatch.';
                resultEl.className = 'result miss';
            }

            // Highlight words
            document.querySelectorAll('.word-btn').forEach(btn => {
                const word = btn.dataset.word;
                if (word === targetWord) {
                    btn.classList.add(isHit ? 'correct' : 'reveal');
                } else if (word === chosenWord) {
                    btn.classList.add('incorrect');
                }
            });

            // Reveal target
            document.getElementById('targetReveal').style.display = 'block';
            document.getElementById('targetWord').textContent = targetWord;

            updateStats();
            saveStats();
        }

        // ══════════════════════════════════════════════════════════════
        // STATS
        // ══════════════════════════════════════════════════════════════

        function updateStats() {
            document.getElementById('sessions').textContent = stats.sessions;
            document.getElementById('hits').textContent = stats.hits;

            const rate = stats.sessions > 0 ? (stats.hits / stats.sessions * 100).toFixed(1) : 0;
            document.getElementById('hitRate').textContent = `${rate}%`;

            const chanceRate = 33.3;
            const diff = rate - chanceRate;
            const vsEl = document.getElementById('vsChance');

            if (stats.sessions < 9) {
                vsEl.textContent = '--';
                vsEl.style.color = 'var(--gold)';
            } else {
                vsEl.textContent = diff >= 0 ? `+${diff.toFixed(1)}%` : `${diff.toFixed(1)}%`;
                vsEl.style.color = diff >= 0 ? 'var(--success)' : '#f44336';
            }

            // Update history
            const historyEl = document.getElementById('sessionHistory');
            historyEl.innerHTML = stats.history.slice(-20).map(hit =>
                `<div class="history-dot ${hit ? 'hit' : 'miss'}"></div>`
            ).join('');
        }

        function resetStats() {
            stats.sessions = 0;
            stats.hits = 0;
            stats.history = [];
            updateStats();
            saveStats();
            newSession();
        }

        // ══════════════════════════════════════════════════════════════
        // PERSISTENCE
        // ══════════════════════════════════════════════════════════════

        function saveStats() {
            localStorage.setItem('epoch_SymbolSender_stats', JSON.stringify(stats));
        }

        function loadStats() {
            const saved = localStorage.getItem('epoch_SymbolSender_stats');
            if (saved) {
                const parsed = JSON.parse(saved);
                stats.sessions = parsed.sessions || 0;
                stats.hits = parsed.hits || 0;
                stats.history = parsed.history || [];
            }
        }

        // ══════════════════════════════════════════════════════════════
        // INIT
        // ══════════════════════════════════════════════════════════════

        loadStats();
        updateStats();
        newSession();
    </script>
</body>
</html>
